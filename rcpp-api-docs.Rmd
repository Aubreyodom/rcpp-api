---
title: "Unofficial Rcpp API Documentation"
output:
  pdf_document: default
  html_document: default
date: '`r format(Sys.time(), "%F %T %z")`'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = FALSE)
```

**Warning: This post is a work in progress. It will periodically be updated
as time permits.**

# Introduction

The following **unofficial** API documentation for [Rcpp](http://rcpp.org) is based off some
personal notes and teaching materials that I have prepared over the years of
working with Rcpp. I've attempted to reformat the notes in the form of [Armadillo's API](http://arma.sourceforge.net/docs.html),
which I think are some of the best documentation out there for a C++ matrix library.
At some point, when the documentation becomes a bit more stable or if there is 
larger contributor interest, I will likely attempt to merge this into the Rcpp 
project so that a docs subdomain could hopefully be added to <http://rcpp.org>.

Please note: The post is written using [RMarkdown](http://rmarkdown.rstudio.com)
for maximum flexibility.

# API Documentation for Rcpp 0.12.8

## Preamble

- The goal of the API documentations are to provide a public facing concise 
  view of Rcpp features. As a result, the documentation will be somewhat long.
  To help navigate the documentation, it has been split into different section.
  Furthermore, one should use the built in search functionality to search text
  for keywords using either `CNTRL` + `F` on Windows and Linux or `CMD` + `F` on
  macOS. 

- Presently, any contribution to this document may be down by a [pull request
  (PRs)](https://github.com/coatless/rcpp-api/pulls) on GitHub.

- Please report any bugs to the [Rcpp Core Team](https://github.com/rcppcore/rcpp/issues).
 
## Overview

- Vector, Matrix, List, DataFrame
- Member functions
- Sugar
    - Statistical Distributions
- Environment, Function, Language
- XPtr
- S4 classes / modules

------

## Vector, Matrix, List, and DataFrame Classes

|                                                                 |                    |
|-----------------------------------------------------------------|--------------------|
|  [Vector<*RTYPE*>, NumericVector, IntegerVector, ...](#vector)  | vector class       |
|  [Matrix<*RTYPE*>, NumericMatrix, IntegerMatrix, ...](#matrix)  | matrix class       |
|  [List](#list)                                                  | list class         |
|  [DataFrame](#dataframe)                                        | data frame class   |

## Member functions

|                                       |                                                                    |
|---------------------------------------|--------------------------------------------------------------------|
|  [Operators](#ops)                    | Mathematical (add, subtract, etc) and logical (inequalities)       |
|  [Dimensional Information](#diminfo)  | Size attribute information                                         |
|  [Object Access](#elemaccess)         | Retrieving element values with and without bounds check            |
|  [Subset Views](#subview)             | Subset data structures                                             |

## Sugar

**[Logical Operations](#sugarlogic)**

|                              |                            |
|:-----------------------------|:---------------------------|
| [`ifelse`](#ifelse)          | Vectorized If-else         |
| [`is_false`](#isbool)        | Is Value False?            |
| [`is_true`](#isbool)         | Is Value True?             |
| [`any`](#any)                | At Least One Value is True |
| [`all`](#all)                | All Values Must be True    |

**[Complex Operators](#sugarcomplex)**

|                              |                                    |
|:-----------------------------|:-----------------------------------|
| [`Re`](#realnums)            | Real Values of Complex Number      |
| [`Im`](#imaginarynums)       | Imaginary Values of Complex Number |
| [`Mod`](#complexmodulus)     | Modulus (r)                        |
| [`Conj`](#complexconjugate)  | Complex Conjugate                  |

**[Data Operations](#sugardata)**

|                         |                                               |
|:------------------------|:----------------------------------------------|
| [`abs`](#abs)           | Absolute Value                                |
| [`sqrt`](#sqrt)         | Square Root                                   |
| [`sum`](#sum)           | Summation                                     |
| [`diff`](#diff)         | Lagged Difference                             |
| [`cumsum`](#carth)      | Cumulative Sum                                |
| [`cumprod`](#carth)     | Cumulative Product                            |
| [`cummin`](#cext)       | Cumulative Minimum                            |
| [`cummax`](#cext)       | Cumulative Maximum                            |
| [`sin`](#trig)          | Sine                                          |
| [`cos`](#trig)          | Cosine                                        |
| [`tan`](#trig)          | Tangent                                       |
| [`asin`](#trig)         | Arc Sine                                      |
| [`acos`](#trig)         | Arc Cosine                                    |
| [`atan`](#trig)         | Arc Tangent                                   |
| [`sinh`](#trig)         | Hyperbolic Sine                               |
| [`cosh`](#trig)         | Hyperbolic Cosine                             |
| [`tanh`](#trig)         | Hyperbolic Tangent                            |
| [`ceiling`](#rounding)  | Smallest integer greater than or equal to x   |
| [`ceil`](#rounding)     | Smallest integer greater than or equal to x   |
| [`trunc`](#rounding)    | Truncates the values in x toward 0            |
| [`floor`](#rounding)    | Largest integer less than or equal to x       | 
| [`round`](#rounding)    | Round values to specified decimal place       |
| [`signif`](#rounding)   | Rounds values to number of significant digits |
| [`log`](#logexp)        | Natural Logarithms                            |
| [`exp`](#logexp)        | Expoential                                    |
| [`log10`](#logexp)      | Base 10 Logarithm                             |
| [`log1p`](#logexp)      | Natural Logarithm $log(1+x)$                  |
| [`expm1`](#logexp)      | $\exp(x) - 1$                                 |

**[Finite, Infinite and NaN Detection](#sugarfinite)**

|                                    |                                          |
|:-----------------------------------|:-----------------------------------------|
| [`pre-defined`](#sugarnanvalues)   | Pre-defined NA/NaN/Inf Constants         |
| [`is_na`](#missingness)            | Detects if values are missing            |
| [`is_nan`](#missingness)           | Detects if values are not a number (NaN) |
| [`is_finite`](#finite)             | Detects if value is finite               |
| [`is_infinite`](#finite)           | Detects if value is infinite             |



**[The Apply Family](#apply)**

|                       |                                                               |
|:----------------------|:--------------------------------------------------------------|
| [`sapply`](#sapply)   | Apply a function to one input and store results in vector     |
| [`lapply`](#lapply)   | Apply a function to one input and store results in list       |
| [`mapply`](#mapply)   | Apply a function to multiple inputs and store results in list |


**[Special Functions of Mathematics](#sugarmath)**

|                             |                            |
|:----------------------------|:---------------------------|
| [`factorial`](#combs)       | Factorial                  |
| [`lfactorial`](#combs)      | Factorial Logarithm        |
| [`choose`](#combs)          | Combination                |
| [`lchoose`](#combs)         | Combination Logarithm      |
| [`gamma`](#gamma)           | Gamma Function             |
| [`lgamma`](#gamma)          | Natural Log Gamma Function |
| [`psigamma`](#gammaderiv)   | General Gamma Derivative   |
| [`digamma`](#gammaderiv)    | Second Gamma Derivative    |
| [`trigamma`](#gammaderiv)   | Third Gamma Derivative     |
| [`tetragamma`](#gammaderiv) | Fourth Gamma Derivative    |
| [`pentagamma`](#gammaderiv) | Fifth Gamma Derivative     |

**[Statistical Summaries](#sugarstats)**

|                      |                      |
|:---------------------|:---------------------|
| [`min`](#minmax)     | Minimum Value        |
| [`max`](#minmax)     | Maximum Value        |
| [`range`](#range)    | Range                |
| [`mean`](#mean)      | Mean Value           |
| [`median`](#median)  | Median Value         |
| [`var`](#median)     | Variance             |
| [`sd`](#var)         | Standard Deviation   |

**[Special Operators](#sugarspecops)**

|                        |                                      |
|:-----------------------|:-------------------------------------|
| [`rev`](#rev)          | Reverse ordering of a vector         |
| [`pmax`](#pext)        | Parallel maximum value               |
| [`pmin`](#pext)        | Parallel minimum value               |
| [`clamp`](#clamp)      | Values between a minimum and maximum |
| [`which_max`](#which)  | Index of the maximum value           |
| [`which_min`](#which)  | Index of the minimum value           |


**[Uniqueness Operators](#sugarunique)**

|                              |                                                                |
|:-----------------------------|:---------------------------------------------------------------|
| [`match`](#match)            | Find indices of the first value in a separate vector           |
| [`self_match`](#match)       | Find indices of the first occurrence of each value in a vector |
| [`unique`](#unique)          | Obtain the unique values                                       |
| [`duplicated`](#unique)      | Obtain a logical vector indicating the duplicate values        |
| [`table( X, N )`](#table)    | Create a frequency table of occurrences                        |
| [`setdiff( X, N )`](#setdiff)| Asymmetric Difference of Set Values                            |



**[Object Creation](#sugarobject)**

|                     |                                                |
|:--------------------|:-----------------------------------------------|
| [`cbind`](#cbind)   | Create matrix by combing column vectors        |
| [`seq_along`](#seq) | Generate an R index sequence given a vector    |
| [`seq_len`](#seq)   | Generate an R index sequence given an integer  |
| [`rep`](#rep)       | Replicate vector $N$ times                     |
| [`rep_each`](#rep)  | Replicate each element in line $N$ times       |
| [`rep_len`](#rep)   | Replicate values until vector is of length $N$ |


**[Statistical Distributions](#statdist)**


**[Discrete Distributions](#discretedist)**

|                                |                        |
|--------------------------------|------------------------|
|  [p/d/q/rbinom](#bindist)      | Binomial               |
|  [p/d/q/rgeom](#geodist)       | Geometric              |
|  [p/d/q/rhyper](#hypergeodist) | Hypergeometric         |
|  [p/d/q/rnbinom](#negbindist)  | Negative Binomial      |
|  [p/d/q/rpois](#poisdist)      | Poisson                |
|  [p/d/q/rwilcox](#wilcoxdist)  | Wilcoxon               |
|  [p/d/q/rsignrank](#signeddist)| Wilcoxon Signed Rank   |


**[Continuous Distributions](#contdist)**

|                                 |                              |
|---------------------------------|------------------------------|
|  [p/d/q/rbeta](#betadist)       | Beta                         |
|  [p/d/q/rcauchy](#cauchydist)   | Cauchy                       |
|  [p/d/q/rchisq](#chisquaredist) | Chi-square                   |
|  [p/d/qnchisq](#nchisquaredist) | Non-central Chi-square       |
|  [p/d/q/rexp](#expdist)         | Exponential                  |
|  [p/d/q/rf](#fdist)             | F                            |
|  [p/d/q/rgamma](#gammadist)     | Gamma                        |
|  [p/d/q/rnorm](#normaldist)     | Normal                       |
|  [p/d/q/rlnorm](#lognormaldist) | Log Normal                   |
|  [p/d/q/rlogis](#logisticdist)  | Logistic                     |
|  [p/d/q/rt](#tdist)             | Student's T                  |
|  [p/d/q/runif](#unifdist)       | Uniform                      |
|  [p/d/q/rweibull](#weibulldist) | Weibull                      |


## Vector, Matrix, List, and DataFrame Classes {#vmld}

### Vector {#vector}

- The templated `Vector` class is a one dimensional array-like structure 
  providing storage for homogenous data types, with an 
  interface similar to that of `std::vector`. Being an implementation of 
  [policy-based design](https://en.wikipedia.org/wiki/Policy-based_design), 
  much of the behavior of `Vector` is determined by the policy classes it 
  inherits from 
  
    - `RObjectMethods` 
    - `StoragePolicy` 
    - `SlotProxyPolicy` 
    - `AttributeProxyPolicy` 
    - `NamesProxyPolicy` 
    
    as well as the CRTP base class `VectorBase`. This type is instantiated as 
    `Vector<RTYPE>`, where `RTYPE` is one of the following valid `SEXPTYPE`s: 
    
    - `REALSXP` 
    - `INTSXP` 
    - `CPLXSXP` 
    - `LGLSXP` 
    - `STRSXP` 
    - `VECSXP`
    - `EXPRSXP`

- For convenience, the following [`typedefs` have been defined](https://github.com/RcppCore/Rcpp/blob/6f81b4684481dbd9bb554dd95e66725fc3b63a8c/inst/include/Rcpp/vector/instantiation.h#L27-L38) in the `Rcpp` namespace: 

    - `NumericVector`    = `Vector<REALSXP>`
    - `IntegerVector`    = `Vector<INTSXP>`
    - `ComplexVector`    = `Vector<CPLXSXP>`
    - `LogicalVector`    = `Vector<LGLSXP>`
    - `CharacterVector`  = `Vector<STRSXP>` 
    - `StringVector`     = `Vector<STRSXP>` 
    - `GenericVector`    = `Vector<VECSXP>` 
    - `List`             = `Vector<VECSXP>` 
    - `ExpressionVector` = `Vector<EXPRSXP>`

- Within this documentation, the default type used will be `NumericVector` unless
another data type is required to show a specific feature.

- Constructors:
    - `Vector()`
    - `Vector(SEXP x)`
    - `Vector(const int &size, const stored_type &u)`
    - `Vector(const std::string &st)`
    - `Vector(const char *st)`
    - `Vector(const Vector &other)`
    - `Vector(const int &size)`
 	  - `Vector(const Dimension &dims)`
    - `Vector(const Dimension &dims, const U &u)`
    - `Vector(const Vector &other)`

- By default, the vectors constructed from dimensions will always be 
  initialized with all entries being zero (`0`) or an empty string (`""`).

- For the majority of cases, the interface being used is that of the R to C++
  interface that relies upon the `Vector(SEXP x)` constructor, which establishes
  a **pointer** to the underlying data. That is, the `Vector` object _points_ to
  the memory location of the `SEXP` R object in order to avoid copying the data
  into _C++_. The only exception to this rule is if the data passed is of a
  different type in which case a deep copy is performed _before_ a pointer is
  established. For example, if `numeric()` data is passed to `NumericVector`
  the correct handoff occurs. However, if `integer()` data were to be passed to
  a `NumericVector` a `clone()` would be made to type `numeric()` which has its
  pointer then assigned to the `NumericMatrix`.

- Examples:

```{Rcpp rcpp_vector_ctor}
SEXP A;
NumericVector B(A); // from a SEXP

// create a vector of length 5 filled with 0
NumericVector C(5);
// Output: 0 0 0 0 0

// construct a filled vector of size 3 with 2.0
NumericVector D = NumericVector(3, 2.0); 
// Output: 2 2 2

// initialize empty numeric vector of size 5
NumericVector D2 = no_init(5);

// fill vector with 3.0
D2.fill(3.0);
// Output: 3 3 3 3 3

// cloning (deep copy)
NumericVector E = clone(D);
// Output: 2 2 2
```

- See also:
    - [Vector Class doxygen documentation](http://dirk.eddelbuettel.com/code/rcpp/html/classRcpp_1_1Vector.html)
    - [`typedef` at cppreference.com](http://en.cppreference.com/w/cpp/language/typedef)

------
 
### Matrix {#matrix}

- The main class for matrices is the templated `Matrix` class, which derives from
  a combination of both the `Vector` and `MatrixBase` types. Like the `Vector` 
  class, `Matrix` uses the policy-based design pattern to manage the lifetime of 
  its undelying `SEXP` via the template parameter `StoragePolicy`, which 
  uses the `PreserveStorage` policy class by default. Matrices are  
  instantiated as `Matrix<RTYPE>`, where the value `RTYPE` is one of the 
  following `SEXPTYPE`s: 
  
    - `REALSXP` 
    - `INTSXP` 
    - `CPLXSXP` 
    - `LGLSXP` 
    - `STRSXP`
    - `VECSXP` 
    - `EXPRSXP`


- For convenience, the following [`typedefs` have been defined](https://github.com/RcppCore/Rcpp/blob/6f81b4684481dbd9bb554dd95e66725fc3b63a8c/inst/include/Rcpp/vector/instantiation.h#L40-L50) in the `Rcpp` 
  namespace: 
  
    - `NumericMatrix`    = `Matrix<REALSXP>`
    - `IntegerMatrix`    = `Matrix<INTSXP>`
    - `ComplexMatrix`    = `Matrix<CPLXSXP>`
    - `LogicalMatrix`    = `Matrix<LGLSXP>`
    - `CharacterMatrix`  = `Matrix<STRSXP>` 
    - `StringMatrix`     = `Matrix<STRSXP>` 
    - `GenericMatrix`    = `Matrix<VECSXP>` 
    - `ListMatrix`       = `Matrix<VECSXP>` 
    - `ExpressionMatrix` = `Matrix<EXPRSXP>`


- Within this documentation, the default type used will be `NumericMatrix` unless
another data type is required to show a specific feature. 

- Constructors:
    - `Matrix()` 
    - `Matrix(SEXP x)`
    - `Matrix(const int& nrows_, const int& ncols)` 
    - `Matrix(const int& nrows_, const int& ncols, Iterator start)` 
    - `Matrix(const int& n)`
    - `Matrix(const Matrix& other)` 

- By default, the matrices constructed from dimensions will always be 
  initialized with all entries being zero (`0`) or empty strings (`""`)

- For the majority of cases, the interface being used is that of the R to C++
  interface that relies upon the `Matrix(SEXP x)` constructor, which establishes
  a **pointer** to the underlying data. That is, the `Vector` object _points_ to
  the memory location of the `SEXP` R object in order to avoid copying the data
  into _C++_. The only exception to this rule is if the data passed is of a
  different type in which case a deep copy is performed _before_ a pointer is
  established. For example, if `numeric()` data is passed to `NumericMatrix`
  the correct handoff occurs. However, if `integer()` data were to be passed to
  a `NumericMatrix` a `clone()` would be made to type `numeric()` which has its
  pointer then assigned to the `NumericMatrix`.

- Examples:

```{Rcpp rcpp_matrix_ctor}
SEXP A;
NumericMatrix B(A); // from a SEXP

// create a square matrix (all elements set to 0.0)
NumericMatrix C(2);
// Output:
// 0 0
// 0 0

// of a given size (all elements set to 0.0)
NumericMatrix D(2, 3);
// Output:
// 0 0 0
// 0 0 0

// of a given size with dimensions (all elements set to 0.0)
NumericMatrix D2(Dimension(3, 2));
// Output:
// 0 0
// 0 0
// 0 0

// initialize empty numeric matrix
NumericMatrix D3 = no_init(2, 1);

// fill matrix with 3.0
D3.fill(3.0);
// Output:
// 3.0
// 3.0

// fill matrix using a vector
NumericVector E = NumericVector(15, 2.0); 
NumericMatrix F = NumericMatrix(3, 5, E.begin());
// Output:
// 2 2 2 2 2
// 2 2 2 2 2
// 2 2 2 2 2

// cloning (explicit deep copy)
NumericMatrix G = clone(F);
```

- See also:
    - [`Matrix` Class doxygen documentation](http://dirk.eddelbuettel.com/code/rcpp/html/classRcpp_1_1Matrix.html)
    - [`typedef` at cppreference.com](http://en.cppreference.com/w/cpp/language/typedef)

### List {#list}

- Generic Storage that is a `typedef` of `Vector` ...

### DataFrame {#dataframe}

- The `DataFrame` class is special type of a `List`, which are in turn a version of `Vector`.


## Vector and Matrix Member Functions

### Operators {#ops}

- Operators allow for operations to take place between two different objects. 
  The operations are defined to works in an element-wise fashion where applicable.

- Viable mathematical operations that are able to be performed.

| Operation | Definition         | Vector-Vector | Vector-Scalar  | Vector-Matrix | Matrix - Matrix | Matrix - Scalar |
|:---------:|:------------------:|:-------------:|:--------------:|:-------------:|:---------------:|:---------------:|
|    +      | Addition           |       Yes     |     Yes        |     No        |       No        |       Yes       |
|    -      | Subtraction        |       Yes     |     Yes        |     No        |       No        |       Yes       |
|    /      | Division           |       Yes     |     Yes        |     No        |       No        |       Yes       |
|    *      | Multiplication     |       Yes     |     Yes        |     No        |       No        |       Yes       |


- Logical Operations

| Operation | Definition                | Vector-Vector | Vector-Scalar  |  Vector-Matrix  | Matrix - Matrix | Matrix - Scalar |
|:---------:|:-------------------------:|:-------------:|:--------------:|:---------------:|:---------------:|:---------------:|
|   ==      | Equality                  |       Yes     |     Yes        |     No          |       No        |       Yes       |
|   !=      | Non-equality              |       Yes     |     Yes        |     No          |       No        |       Yes       |
|   >=      | Greater than or equal to  |       Yes     |     Yes        |     No          |       No        |       Yes       |
|   <=      | Less than or equal to     |       Yes     |     Yes        |     No          |       No        |       Yes       |
|   <       | Less than                 |       Yes     |     Yes        |     No          |       No        |       Yes       |
|   >       | Greater than              |       Yes     |     Yes        |     No          |       No        |       Yes       |

- Examples:
 
```{Rcpp}
// Sample data
NumericVector A = NumericVector::create(1, 2, 3, 4);
NumericVector B = NumericVector::create(2, 3, 4, 5);

// --- Addition

// Add a vector and scalar
NumericVector H = A + 2.0;
// Output: 3 4 5 6

// Add a vector and another vector
NumericVector I = A + B;
// Output: 3 5 7 9

// --- Subtraction

// Subtract a scalar from a vector
NumericVector J = 2.0 - A;
// Output: 1 0 -1 -2

// Subtract vectors
NumericVector K = A - B;
// Output: -1 -1 -1 -1

// --- Multiplication

// Multiple by scalar
NumericVector L = 3 * A;
// Output: 3 6 9 12

// Multiple Vectors
NumericVector M = A * B;
// Output: 2 6 12 20

// --- Division

// Divide by scalar
NumericVector L = 1 / A;
// Output: 1.0000000 0.5000000 0.3333333 0.2500000

// Divide Vectors
NumericVector M = A / B;
// Output: 0.5000000 0.6666667 0.7500000 0.8000000

// --- All together
NumericVector res = 3.0 * A - 1.0 / B + A + B + 5.0;
// Output: 10.50000 15.66667 20.75000 25.80000
```

### Dimensional Information {#diminfo}

|               |                                           |
|:--------------|:------------------------------------------|
| `.nrow()`	   	| number of rows in a `Matrix`              |
| `.ncol()`	   	| number of columns in a `Vector`           |
| `.size()`   	| number of items in a `Matrix` or `Vector` |
| `.length()`   | alias of `size()` for `Vector`            |

- Return type is that of an `int`, `unsigned int`, or `R_xlen_t`

- Examples:

```{Rcpp}
// --- Vector Example
NumericVector X(3);

int nelem = X.size();   // Output: 3
int nlens = X.length(); // Output: 3

Rcout << "Vector X has " << nelem << " elements." << std::endl;

// --- Matrix Example
NumericMatrix X(4,5);

int rows  = X.nrow();   // Output: 4
int cols  = X.ncols();  // Output: 5
int elems = X.size();   // Output: 20

Rcout << "Matrix Y has " << rows << " rows and " << cols << " columns." << std::endl;
```


### Element Access {#elemaccess}

- Accesses an individual element within a `Vector` or `Matrix`.
   - `(i)` provides the *i*th element in addition to ensure that the requested
       indice is within the confines of the array by doing a bounds check
   - `[i]` similar to the previous case, but does so *without* a bounds check. 
   - `at(i,j)` provides the *i,j*th element of a `Matrix` with a bounds check.
   - `(i,j)` provides the *i,j*th element of a `Matrix` *without* a bounds check.

- Using accessors without a bounds check is **not** recommended unless the code
  has been thoroughly tested as undefined behavior (UB) may emerge. UB 
  is very problematic.
  
- Note: Unlike _R_, there is no `[]` subset operator for matrices with _C++_.
  The reason for the lack of `operator[]` relates to a fundamental design choice 
  made by the creators of C++ related to the presence of the 
  [`operator,`](http://en.cppreference.com/w/cpp/language/operator_other#Built-in_comma_operator).
  In essence, after the complete evaluation of the first coordinate `x` and disposal
  of the results, only then is the second coordinate `y` able to be evaluated.
  Unfortunately, this yields the following `-Wall` issue: 
  > left operand of comma operator has no effect.
  
  Therefore, the only viable matrix subset operators within C++ are `operator()` and `operator at()` provide subset operations.

- Examples:

```{Rcpp}
// Create a vector 
NumericVector Y = NumericVector::create(1, 2, 3, 4);

// Retrieve the first value from Y. (C++ indices start at 0 not 1!)
double a = Y(0);
// Output: 1

// Modify the last value using unbound accessor
// Warning: Make sure the point is valid!
Y[3] = 5;

// Create matrix with elements in Y
NumericMatrix Y(2, 2, X.begin());

// Output:
// 1  3
// 2  5

// Extract Value at 2, 1
double b = Y(1, 0);
// Output: 2

// Modify value at 1, 2
Y(0, 1) = 4;

// Output:
// 1  4
// 2  5

// The following shows a bounds throw error
// Y.at(1, 2) = 4;
```

### Subset Views {#subview}

### Static Member Functions {#staticfunc}

## Environment

## Function

## Language

## XPtr

## S4 Classes

## Sugar

### Logical Operations {#sugarlogic}

#### ifelse( CONDITION, TRUE, FALSE) {#ifelse}

#### all( X ) {#all}

- Tests if *all* elements in a `LogicalVector` or `LogicalMatrix` are `true`. 

- The actual return type of `all(X)` is an instance of the 
  `SingleLogicalResult` template class, but the functions `is_true` 
  and `is_false` may be used to convert the return value to `bool`.
  
- Examples: 

```{Rcpp, all}
NumericVector x = NumericVector::create(1.0, 2.0, 3.0, 4.0);

Rcout
    << std::boolalpha
    << "all(x < 5): " << is_true(all(x < 5)) << "\n"
    << "all(x < 4): " << is_true(all(x < 4)) << "\n"
    << "all(!is_na(x)): " << is_true(all(!is_na(x))) 
    << "\n\n";
// Output:
// all(x < 5): true
// all(x < 4): false
// all(!is_na(x)): true

NumericMatrix y(2, 2, x.begin());

Rcout
    << std::boolalpha
    << "all(y < 5): " << is_true(all(y < 5)) << "\n"
    << "all(y < 4): " << is_true(all(y < 4)) << "\n"
    << "all(!is_na(y)): " << is_true(all(!is_na(y))) 
    << "\n\n";
// Output:
// all(y < 5): true
// all(y < 4): false
// all(!is_na(y)): true

Rcout
    << std::boolalpha
    << "all({true, true, true}): "
    << is_true(all(LogicalVector::create(true, true, true))) << "\n"
    << "all({true, true, false}): "
    << is_true(all(LogicalVector::create(true, true, false))) 
    << std::endl;
// Output: 
// all({true, true, true}): true
// all({true, true, false}): false
```

- See also:
    - [any](#any)
    - [is_true](#is-true)

#### any( X ) {#any}

- Tests if *any* elements in a `LogicalVector` or `LogicalMatrix` are `true`. 

- The actual return type of `any(X)` is an instance of the 
  `SingleLogicalResult` template class, but the functions `is_true` 
  and `is_false` may be used to convert the return value to `bool`.
  
- Examples: 

```{Rcpp, any}
NumericVector x = NumericVector::create(1.0, 2.0, 3.0, 4.0);

Rcout
    << std::boolalpha
    << "any(x > 3): " << is_true(any(x > 3)) << "\n"
    << "any(x > 4): " << is_true(any(x > 4)) << "\n"
    << "any(is_na(x)): " << is_true(any(is_na(x))) 
    << "\n\n";
// Output:    
// any(x > 3): true
// any(x > 4): false
// any(is_na(x)): false

NumericMatrix y(2, 2, x.begin());
y[0] = NumericMatrix::get_na();

Rcout
    << std::boolalpha
    << "any(y > 3): " << is_true(any(y > 3)) << "\n"
    << "any(y > 4): " << is_true(any(y > 4)) << "\n"
    << "any(is_na(y)): " << is_true(any(is_na(y))) 
    << "\n\n";
// Output:    
// any(y > 3): true
// any(y > 4): false
// any(is_na(y)): true

Rcout
    << std::boolalpha
    << "any({false, false, false}): "
    << is_true(any(LogicalVector::create(false, false, false))) << "\n"
    << "any({true, false, false}): "
    << is_true(any(LogicalVector::create(true, false, false))) 
    << std::endl;
// Output:
// any({false, false, false}): false
// any({true, false, false}): true
```

- See also:
    - [all](#all)
    - [is_true](#is-true)

### Complex Operators {#sugarcomplex}

#### Re( X ) {#realnums}

#### Im( X ) {#imaginarynums}

#### Mod( X ) {#complexmodulus}

#### Conj( X ) {#complexconjugate}


### Data Operations {#sugardata}


#### Preview Data {#prevdata}

|                   |                   |
|:------------------|:------------------|
| **head( X , N )** | **tail( X , N )** |

----

#### abs( X ) {#abs}

- Compute the absolute value of all elements in a Vector or Matrix. 

- Example:

```{Rcpp}
// Sample data
NumericVector x = NumericVector::create(-2.8, 5.3, 7, -4, 0);

NumericVector y = abs(x);
// Output: 2.8, 5.3, 7, 4, 0
```

----

#### sqrt( X ) {#sqrt}

----

#### sum( X ) {#sum}

- Compute the overall summation of all elements in a Vector or Matrix. 

- Examples:

```{Rcpp}
// Sample data
NumericVector x = NumericVector::create(3.2, 8.1, 9.5, 8.6, 5.7);

double y = sum(x);
// Output: 35.1
```

- See also:
    - [rowSums](#rowSums)
    - [colSums](#colSums)

----

#### diff( X ) {#diff}

----

#### Cumulative Arithmetic {#carth}

|                 |                  |
|:----------------|:-----------------|
| **cumsum( X )** | **cumprod( X )** |

- Calculates the cumulative sum (`cumsum`) or cumulative product (`cumprod`) 
  of a `Vector` or `Matrix` *X*. 
  
- If an `NA` value is encountered, it will be propagated throughout the 
  remaining elements in the result vector. 

- For `cumsum`, *X* should be an `Integer` or `Numeric` `Vector` or `Matrix`. 

- For `cumprod`, *X* should be an `Integer`, `Numeric`, or `Complex` `Vector` 
  or `Matrix`. 
  
- In either case, the return type is a `Vector` of the same underlying `SEXPTYPE` 
  as the input. 
  
- Caveat: at the time of writing (Rcpp version 0.12.8.2), not all Sugar expressions 
  are directly compatible with `Vector::operator=`, as many of these functions 
  return intermediate template classes which require an explicit conversion to   
  `Vector`, rather than directly returning a `Vector`. In such cases the user 
  may need to "help" the compiler with the conversion by 
  
    - Constructing a `Vector` from the result, and assigning that to the 
      target `Vector`; or
    - Calling an explicit conversion member function of the Sugar class, if 
      such a function exists.
      
    See the examples below for a demonstration. 
  
- Examples: 

```{Rcpp}
NumericVector x = NumericVector::create(1, 2, 3, 4, 5);
NumericVector cs = cumsum(x), cp = cumprod(x);

Rcout
    << "cumsum(x): \n" << cs << "\n\n"
    << "cumprod(x): \n" << cp << "\n\n";
// Output:
// cumsum(x): 
// 1 3 6 10 15
// 
// cumprod(x): 
// 1 2 6 24 120

x[3] = NumericVector::get_na();

cs = cumsum(x).get();
cp = cumprod(x).get();

// These print as `nan`, but are actually `NA` values
Rcout
    << "cumsum(x): \n" << cs << "\n\n"
    << "cumprod(x): \n" << cp 
    << std::endl;
// Output: 
// cumsum(x): 
// 1 3 6 nan nan
// 
// cumprod(x): 
// 1 2 6 nan nan

// As noted above: 
NumericVector y = NumericVector::create(1, 2, 3, 4, 5);

NumericVector cs = cumsum(y);   // OK, calls copy *constructor*, not 
                                // copy assignment operator

// cs = cumsum(y);      compiler error: no viable conversion from 
//                      'const Rcpp::sugar::Cumsum<14, true, Rcpp::Vector<14, PreserveStorage> >' 
//                      to 'SEXP' (aka 'SEXPREC *')

cs = cumsum(y).get();           // OK, `get()` returns a VectorBase, which is 
                                // assignable to Vector
                                
cs = NumericVector(cumsum(y));  // OK, but requires an additional Vector 
                                // to be created
```

----

#### Cumulative Extremum {#cext}

|                 |                  |
|:----------------|:-----------------|
| **cummax( X )** | **cummin( X )**  |


----


#### trigonometric element-wise functions {#trig}

|              |                |               |
|:-------------|:---------------|:--------------|
| **sin( X )** | **asin( X )**  | **sinh( X )** |
| **cos( X )** |  **acos( X )** | **cosh( X )** |
| **tan( X )** |  **atan( X )** | **tanh( X )** |

- Compute the trigonometric value for each element in a given structure.

- Usage:
   - `vector_type Y = func(X)`
   - `matrix_type Y = func(X)`
   - `X` and `Y` must be of the same `vector_type`/`matrix_type`.
   - where `func` is one of the following trigonmetric functions:
       - sin family: `sin(X)`, `asin(X)`, `sinh(X)`
       - cos family: `cos(X)`, `acos(X)`, `cosh(X)`
       - tan family: `tan(X)`, `atan(X)`, `tanh(X)`

- Examples:

```{Rcpp rcpp_trig_funcs}
// Generate Values
NumericVector X  = rnorm(10);

// Compute trigonometric values
NumericVector Y  =  cos(X);
NumericVector Y2 = acos(X);
NumericVector Y3 = cosh(X);
```

---

#### Rounding of Numbers {#rounding}

|                        |                         |
|:-----------------------|:------------------------|
| **ceiling( X )**       | **ceil( X )**           | 
| **trunc( X )**         | **floor( X )**          | 
| **round( X, digits )** | **signif( X, digits )** |

---

#### Logarithms and Exponentials {#logexp}

|              |                |                |
|:-------------|:---------------|:---------------|
| **log( X )** | **log10( X )** | **log1p( X )** | 
| **exp( X )** | **expm1( X )** |                |


---

### Finite, Infinite, Missingness, and NaN Detection {#sugarnan}

- Finite numerical representations take the form of base 10 numbers like 1, 2,
  ..., 42, and so on. These values are able to be operated upon such that
  a collection of numerical values can provide a statistical summary.
  However, when working with values that hold special meanings the representation,
  is not necessarily ideal. Therefore, a set of tools exists to detect when 
  values with special meanings exist.

- From [Kevin Ushey's post on StackOverflow](http://stackoverflow.com/questions/26241085/rcpp-function-check-if-missing-value/26262984#26262984),
  we have a set of truth tables or an indicator of whether the value is detected
  by a given function, which covers the R interpreter, Rcpp, and R/C API. Note,
  Rcpp by default follows how R interpreter has crafted the methods.

- R interpreter:

| Function   | `NaN` | `NA` |
|:-----------|:-----:|:----:|
| `is.na`    |  `T`  | `T`  |
| `is.nan`   |  `T`  | `F`  |

- Rcpp:

| Function       | `NaN` | `NA` |
|:---------------|:-----:|:----:|
| `Rcpp::is_na`  |  `T`  | `T`  |
| `Rcpp::is_nan` |  `T`  | `F`  |

- R/C API:

| Function   | `NaN` | `NA`|
|:-----------|:-----:|:---:|
| `ISNAN`    |  `T`  | `T` |
| `R_IsNaN`  |  `T`  | `F` |
| `ISNA`     |  `F`  | `T` |
| `R_IsNA`   |  `F`  | `T` |

- Note: The R/C API is highly inconsistent when detecting values.


#### Setting Infinite, Missingness, and NaN Values {#sugarnanvalues}

- To indicate missingness or `NA` values, the following pre-defined constants 
  have been made available for specific Rcpp data types:

|     Rcpp Data Type       |     Rcpp Value    | Description              |
|:------------------------:|:-----------------:|:------------------------:|
| Numeric<Vector/Matrix>   | `NA_REAL`         | Numeric Missing Value    |
| Integer<Vector/Matrix>   | `NA_INTEGER`      | Integer Missing Value    |
| Logical<Vector/Matrix>   | `NA_LOGICAL`      | Logical Missing Value    |
| Character<Vector/Matrix> | `NA_STRING`       | String Missing Value     |


- To set a missing value type for any type of `Vector` or `Matrix` regardless of
  whether a pre-defined exists, one can use the static member `::get_na()`, e.g.
  `ComplexVector::get_na()` creates an `NA` value for a complex vector.

- The `Numeric` and `double` data types also support the following special 
  constant values:

|     Rcpp Value  |   Value    | Description        |
|:---------------:|:----------:|:------------------:|
|    `R_PosInf`   | `Inf`      | Positive Infinity  |
|    `R_NegInf`   | `-Inf`     | Negative Infinity  |
|    `R_NaN`      | `NaN`      | Not a Number       |

- Note: Understanding the breakdown of the values is important as it relates to 
  detecting whether an element is [finite](#finite), 
  [missing or computationally problematic](#missingness).

- Examples 

```{Rcpp}
// Create an NA value for each type
NumericVector A   = NumericVector::create(NA_REAL);
IntegerVector B   = IntegerVector::create(NA_INTEGER);
LogicalVector C   = LogicalVector::create(NA_LOGICAL);
CharacterVector D = CharacterVector::create(NA_STRING);
// Output: NA

// Group all of the above together
List E = List::create(A, B, C, D);
```

---

#### Finiteness {#finite} 

|                    |                      |
|:-------------------|:---------------------|
| **is_finite( X )** | **is_infinite( X )** |

---

#### Missing Values and NaN Detection {#missingness}

|                    |                      |
|:-------------------|:---------------------|
|    **is_na( X )**  |    **is_nan( X )**   |


- Determines the missing values (`is_na`) or not a number (`is_nan`) 
  of a `Vector` or `Matrix` *X*. 


- Note: The difference between the two functions is explained by in the truth
  table
  

| Function       | `NaN` | `NA` |
|:---------------|:-----:|:----:|
| `Rcpp::is_na`  |  `T`  | `T`  |
| `Rcpp::is_nan` |  `T`  | `F`  |


- Examples:

```{Rcpp}
NumericVector X = NumericVector::create(R_NaN, 1, NA_REAL, 3 ) ;

LogicalVector result_na = is_na( X );
// Output: TRUE, FALSE, TRUE, FALSE

LogicalVector result_nan = is_nan( X );
// Output: TRUE, FALSE, FALSE, FALSE
```

---

### The Apply Family {#apply}

#### lapply {#lapply}

---

#### mapply {#mapply}

---

#### sapply {#sapply}

---

### Special Functions of Mathematics

#### Beta {#beta}

|               |                |
|:--------------|:---------------|
| **beta( X )** | **lbeta( X )** |

---

#### Gamma {#gamma}

|               |                  |
|:--------------|:-----------------|
| **gamma( X )** | **lgamma( X )** |

|                            |                     |
|:---------------------------|:--------------------|
| **psigamma( X , deriv )**  |                     |
| **digamma( X )**           | **trigamma( X )**   |
| **tetragamma( X )**        | **pentagamma( X )** |

---

### Combinatorics {#combs}

|                 |                  |
|:----------------|:-----------------|
| **factorial()** | **lfactorial()** |
| **choose()**    | **lchoose()**    |


---

### Statistical Summaries

#### Minimum and Maximum {#minmax}

|              |              |
|:-------------|:-------------|
| **min( X )** | **max( X )** |

- Obtain the extremum value of either a maximum and minimum from within `Vector` 
  or `Matrix`. 

- Examples:

```{Rcpp}
// Sample Data
NumericVector X = NumericVector::create(3, 4, 9, 5, 1, 2);

// Obtain max value for X
double X_max = max(X);
// Output: 9

// Obtain min value for X
double X_min = minx(X);
// Output: 1
```

---

#### range( X ) {#range}

- Computes the range or the minimum and maximum values of the sample.

- If _X_ is a `Matrix`, then the values will be vectorized and the range computed.
  
```{Rcpp}
// Sample Data
NumericVector X = NumericVector::create(3, 4, 9, 5, 1, 2);

// Obtain range value for X
NumericVector X_range = range(X);
// Output: 1 9
```

---

#### mean( X ) {#mean}

- Computes the sample mean.

- If _X_ is a `Matrix`, it will lump all values together and then compute the 
  mean. To obtain means for each row or column use `rowMeans` or `colMeans`.

```{Rcpp}
// Sample Data
NumericVector X = NumericVector::create(3, 4, 9, 5, 1, 2);

// Obtain mean value for X
double X_mean = mean(X);
// Output: 4
```

---

#### median( X , NA_RM) {#median}

- Computes the sample median of an `Numeric`, `Integer`, or `Logical` `Vector` 
  or `Matrix`

```{Rcpp}
// Sample Data
NumericVector X = NumericVector::create(3,4,9,5,NA_REAL,1,2);

// Obtain the median value for X by removing NAs
double X_median = median(X, true);
// Output: 3.5

// By default, NA is not removed
double X_median_na = median(X);
// Output: NaN
```


---

#### Variance {#var}

|              |             |
|:-------------|:------------|
| **var( X )** | **sd( X )** |

---

### Special Operations

#### rev( X ) {#rev}

----


#### Parallel Extremum {#pext}
|                   |                    |
|:------------------|:-------------------|
| **pmax( X, Y )**  | **pmin( X, Y )**   |

- Obtain a parallel extremum value of either maximum and minimum for either 
  a scalar and a `Vector` or just two `Vector` objects.
  
- For instance, the parallel minimum of X = 0, 1 and Y = 2, -3 would be Z = 0, -3.

- Examples

```{Rcpp}
// Sample Data
NumericVector x = NumericVector::create(1,3,2,4,6,5);
NumericVector y = NumericVector::create(2,1,3,5,4,6);

// --- Parallel Maximum

// Scalar and Vector
NumericVector z = pmax(2, x);
// Output: 2 3 2 4 6 5

// Two vectors
NumericVector z2 = pmax(x, y);
// Output: 2 3 3 5 6 6

// --- Parallel Minimum

// Scalar and Vector
NumericVector z = pmin(2, x);
// Output: 1 2 2 2 2 2

// Two vectors
NumericVector z2 = pmin(x, y);
// Output: 1 1 2 4 4 5
```

#### clamp( X , A , B ) {#clamp}


----

#### Extremum Indice {#which}

|                     |                    |
|:--------------------|:-------------------|
| **which_max( X )**  | **which_min( X )** |

- Provides the position in the vector of the maximum or minimum value of a 
  `NumericVector`.

- Examples:

```{Rcpp}
// Sample data
NumericVector x = NumericVector::create(3.2, 5.2, -9.7, 4.3, 8.8);

// Return index for max value
int y = which_max(x);
// Output: 4 (because C++ indices starts at 0!)

// Return index for min value
int y2 = which_min(x);
// Output: 2 (because C++ indices starts at 0!)
```

----

### Uniqueness Operators {#sugarunique}

#### Match {#match}

|                     |                     |
|:--------------------|:--------------------|
| **match( X )**      | **self_match( X )** |


----

#### Unique {#unique}

|                     |                 |
|:--------------------|:----------------|
| **duplicated( X )** | **unique( X )** |

- Determine whether duplicates exist within a `Vector` or what the unique values
  are.
  
- Duplicated values are identified by a `LogicalVector` such that the first,
  second, and so on replicates are labeled as `TRUE` while unique values are `FALSE`.
  
- Unique provides only the first occurrence of a given value. In essence, only
  the values that appear as `FALSE` within the `duplicate` function.

- Examples:

```{Rcpp}
// Sample data
CharacterVector x = CharacterVector::create("a","b","c","a","b","c","a");

// Detect duplicates within a string
LogicalVector x_dups = duplicated(x);
// Output: FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE

// Obtain only unique values
CharacterVector x_unique = unique(x);
// Output: "a", "b", "c"
```

----

### table( X ) {#table}

- Given a `Vector` of either `NumericVector`, `IntegerVector`, `LogicalVector`,
  or `CharacterVector`, compute an `IntegerVector` that contains a count of
  each value.

- Examples:

```{Rcpp}
// Needs to have a way to extract what value is represented at each position
// names attribute? 

// Create Numerical Data
NumericVector w = NumericVector::create(3.2, 1.2, -0.5, NA_REAL, 1.2, 2.0, NA_REAL);

// Tabulate
IntegerVector w_out = table(x);

// Create Integer Data
IntegerVector x = IntegerVector::create(2, -2, NA_INTEGER, NA_INTEGER, 200, 2);

// Tabulate the integer data
IntegerVector x_out = table(y);

// Create Character Data
CharacterVector y = CharacterVector::create("a", "a", "b", NA_STRING, "c", NA_STRING);

// Tabulate
IntegerVector y_out = table(z);

// Create Logical Data
LogicalVector z = LogicalVector::create(true, NA_LOGICAL, false, true, NA_LOGICAL);

// Tabulate
IntegerVector z_out = table(z);
```

----

#### setdiff(X, Y) {#setdiff}


----

### Object Creation {#sugarobject}

#### cbind {#cbind}

|                      |
|:---------------------|
| **cbind(X, Y)**      |
| **cbind(X, Y, ...)** |


**cbind(X, Y, ...)**

- Creates a `Matrix` by joining objects together in a column-wise manner. 

- *X*, *Y* may be any combination of `Vector`, `Matrix`, or atomic value 
  of the same underlying type *T*, where *T* is one of 
    - `int` 
    - `double`
    - `std::complex<double> / Rcomplex` 
    - `bool`
    
- `cbind` is defined for any number of arguments between 2 and 50, inclusive. 

- Let *S1* and *S2* be scalar (atomic) values, *V* be a `Vector` with length k,
  and *M* be a `Matrix` with with m rows and n columns. The `cbind` function 
  exhibits the following behavior: 
    - `cbind(S1, S2)` returns a 1 x 2 `Matrix`.
    - `cbind(S1, V)` and `cbind(V, S1)` return a k x 2 `Matrix`, where *S1* is 
      recycled k times.
    - `cbind(S1, M)` and `cbind(M, S1)` return an m x (n + 1) `Matrix`, where 
      `S1` is recycled m times.
    - If k and m are equal, `cbind(V, M)` and `cbind(M, V)` return an m x n 
      `Matrix`.
    - If k and m are not equal, `cbind(V, M)` and `cbind(M, V)` will throw an 
      exception at runtime. 
    - *S1* and *S2* may be consecutive arguments in a `cbind` expression IFF:
        - they are the *only* arguments used; or
        - all other arguemnts are also scalars; or
        - non-scalar, adjacent arguments are vectors of length one, or matrices 
          with one row.
    - All other cases involving consecutive arguments *S1* and *S2* will 
      generate a runtime error.
      
- Examples: 
          
```{Rcpp, cbind}
double d = 1.0;
NumericVector v(3, 2.0);
NumericMatrix m(3, 2); 
m.fill(3.0);

Rcout 
    << std::setprecision(2) 
    << "cbind(1.5, 2.5):\n" << cbind(1.5, 2.5) << "\n"
    << "cbind(d, v):\n" << cbind(d, v) << "\n"
    << "cbind(v, d):\n" << cbind(v, d) << "\n"
    << "cbind(d, v, m, v, d):\n" << cbind(d, v, m, v, d) 
    << std::endl;
// Output:
// cbind(1.5, 2.5):
// 1.5 2.5
// 
// cbind(d, v):
// 1.0 2.0
// 1.0 2.0
// 1.0 2.0
// 
// cbind(v, d):
// 2.0 1.0
// 2.0 1.0
// 2.0 1.0
// 
// cbind(d, v, m, v, d):
// 1.0 2.0 3.0 3.0 2.0 1.0
// 1.0 2.0 3.0 3.0 2.0 1.0
// 1.0 2.0 3.0 3.0 2.0 1.0
```

#### Sequence Generation {#seq}

|                     |                      |
|:--------------------|:---------------------|
| **seq_along( X )**  | **seq_len( N )**     |


```{Rcpp}
NumericVector A = NumericVector::create(-1, 0, 1);

// By default, seq_along returns R indices
IntegerVector B = seq_along(A);
// Output: 1 2 3

// Generates a vector of specified length
IntegerVector C = seq_len(5);
// Output: 1 2 3 4 5

```


----

#### Replicate Elements {#rep}

|                     |                      |                      |
|:--------------------|:---------------------|:---------------------|
| **rep( X, N )**     | **rep_each( X, N )** | **rep_len( X, N )**  |


```{Rcpp}
NumericVector A = NumericVector::create(-1, 0, 1);

NumericVector B = rep(A, 3);
// Output: -1 0 1 -1 0 1 -1 0 1

NumericVector C = rep_each(A, 3);
// Output: -1 -1 -1 0 0 0 1 1 1

NumericVector D = rep_len(A, 5);
// Output: -1 0 1 -1 0
```


----

## Statistical Distributions {#statdist}

- There exists two approaches for working with statistical distribution functions
  within Rcpp. The approaches differ on how the result is returned. Specifically,
  statistical distributions within the `Rcpp::` namespace return type
  `NumericVector` whereas functions within the `R::` namespace return a single 
  `double` scalar value.
  
- For drawing large samples with fixed distribution parameters, sampling under
  one should sample under the `Rcpp::` namespace to obtain a `NumericVector`.
  There is an added benefit to working under this scheme of having default
  parameters for log probability and lower tail sampling akin to traditional R
  versions.

- For drawing samples with changing distribution parameters, sampling under
  the `R::` namespace with a `for` loop is perferred as parameters for
  each draw can be customized.


### Discrete Distributions {#discretedist}

#### Binomial Distribution {#bindist}

|                                                 |
|:------------------------------------------------|
| **dbinomial(X, SIZE, PROB, LOG_P)**             |
| **pbinomial(Q, SIZE, PROB, LOWER_TAIL, LOG_P)** |
| **qbinomial(P, SIZE, PROB, LOWER_TAIL, LOG_P)** |
| **rbinomial(N, SIZE, PROB)**                    |


```{Rcpp rcpp_bin_dist}
// Consider X ~ Bin(n = 100, p = 0.5)

IntegerVector xx = IntegerVector::create(46, 47, 48, 49, 50, 51, 52, 53, 54);

// Vector returns
NumericVector densities = Rcpp::dbinom(xx, 100, .5, false)
NumericVector probs     = Rcpp::pbinom(xx, 100, .5, true, false);
NumericVector qvals     = Rcpp::qbinom(probs, 100, .5, true, false);
NumericVector rsamples  = Rcpp::rbinom(20, 100, .5); 

// Scalar Returns
double dval  = R::dbinom(46, 100, .5, false);
double pval  = R::pbinom(46, 100, .5, true, false);
double qval  = R::qbinom(0.242, 100, .5, true, false);
int rdraw = R::rbinom(46, 100);
```


#### Geometric Distribution {#geodist}

|                                       |
|:--------------------------------------|
| **dgeom(X, PROB, LOG_P)**             |
| **pgeom(Q, PROB, LOWER_TAIL, LOG_P)** |
| **qgeom(P, PROB, LOWER_TAIL, LOG_P)** |
| **rgeom(N, PROB)**                    |


```{Rcpp rcpp_geo_dist}
// Consider X ~ Geom(p = 0.25)
IntegerVector xx = seq_len(5);

// Vector returns
NumericVector densities = Rcpp::dgeom(xx, .25, false)
NumericVector probs     = Rcpp::pgeom(xx, .25, true, false);
IntegerVector qvals     = Rcpp::qgeom(probs, .25, true, false);
IntegerVector rsamples  = Rcpp::rgeom(20, .25); 

// Scalar Returns
double dval  = R::dgeom(2, .25, false);
double pval  = R::pgeom(2, .25, true, false);
int qval     = R::qgeom(0.578125, .25, true, false);
int rdraw    = R::rgeom(.25);
```

#### Hypergeometric Distribution {#hypergeodist}

|                                            |
|:-------------------------------------------|
| **dhyper( X, M, N, K, LOG_P)**             |
| **phyper( Q, M, N, K, LOWER_TAIL, LOG_P)** |
| **qhyper( P, M, N, K, LOWER_TAIL, LOG_P)** |
| **rhyper(NN, M, N, K)**                    |


```{Rcpp rcpp_hypergeo_dist}
// Consider X ~ Hypergeo(m = 10, n = 7, k = 8)
IntegerVector xx = IntegerVector::create(3, 4, 5, 6, 7);

// Vector returns
NumericVector densities = Rcpp::dhyper(xx, 10, 7, 8, false)
NumericVector probs     = Rcpp::phyper(xx, 10, 7, 8, true, false);
NumericVector qvals     = Rcpp::qhyper(probs, 10, 7, 8, true, false);
NumericVector rsamples  = Rcpp::rhyper(20, 10, 7, 8); 

// Scalar Returns
double dval  = R::dhyper(46, 10, 7, 8, false);
double pval  = R::phyper(46, 10, 7, 8, true, false);
int qval     = R::qhyper(0.4193747, 10, 7, 8, true, false);
int rdraw    = R::rhyper(10, 7, 8);
```

#### Negative Binomial Distribution {#negbindist}

|                                                  |
|:-------------------------------------------------|
| **dnbinomial(X, SIZE, PROB, LOG_P)**             |
| **pnbinomial(Q, SIZE, PROB, LOWER_TAIL, LOG_P)** |
| **qnbinomial(P, SIZE, PROB, LOWER_TAIL, LOG_P)** |
| **rnbinomial(N, SIZE, PROB)**                    |


```{Rcpp rcpp_nbin_dist}
// Consider X ~ NegBin(n = 100, p = 0.5)
IntegerVector xx = IntegerVector::create(46, 47, 48, 49, 50, 51, 52, 53, 54);

// Vector returns
NumericVector densities = Rcpp::dnbinom(xx, 100, .5, false)
NumericVector probs     = Rcpp::pnbinom(xx, 100, .5, true, false);
NumericVector qvals     = Rcpp::qnbinom(probs, 100, .5, true, false);
NumericVector rsamples  = Rcpp::rnbinom(20, 100, .5); 

// Scalar Returns
double dval  = R::dnbinom(46, 100, .5, false);
double pval  = R::pnbinom(46, 100, .5, true, false);
double qval  = R::qnbinom(0.242, 100, .5, true, false);
int rdraw    = R::rnbinom(46, 100);
```

#### Poisson Distribution {#poisdist}

|                                         |
|:----------------------------------------|
| **dpois(X, LAMBDA, LOG_P)**             |
| **ppois(Q, LAMBDA, LOWER_TAIL, LOG_P)** |
| **qpois(P, LAMBDA, LOWER_TAIL, LOG_P)** |
| **rpois(N, LAMBDA)**                    |

- Computes either the density (d), probability (p), quantile (q), or
  a random (r) sample of a vector or scalar from a Poisson distribution.
  
- When simulating a vector or scalar from a Poisson distribution,
  the value returned is within the natural numbers (e.g. $0, 1, 2, \ldots , 42, \ldots , \mathbb{N}$).

- Under vectorization, e.g. `Rcpp::`, the default distribution parameters are
  as follows:
    - `LOG_P = FALSE`, probabilities, densities are returned as $\log(p)$.
    - `LOWER_TAIL = TRUE`, probabilities are calculated by $P(X \le x)$ instead of $P(X > x)$.

- Examples:

```{Rcpp rcpp_pois_dist}
// Consider X ~ Pois(4)
IntegerVector xx = seq_len(10);

// Vector returns
NumericVector densities = Rcpp::dpois(xx, 4, false)
NumericVector probs     = Rcpp::ppois(xx, 4, true, false);
NumericVector qvals     = Rcpp::qpois(probs, 4, true, false);
NumericVector rsamples  = Rcpp::rpois(20, 4); 

// Scalar Returns
double dval  = R::dpois(46, 4, false);
double pval  = R::ppois(46, 4, true, false);
double qval  = R::qpois(0.242, 4, true, false);
int rdraw    = R::rpois(46);
```

### Wilcox Distribution {#wilcoxdist}

|                                          |
|:-----------------------------------------|
| **dwilcox( X, M, N, LOG_P)**             |
| **pwilcox( Q, M, N, LOWER_TAIL, LOG_P)** |
| **qwilcox( P, M, N, LOWER_TAIL, LOG_P)** |
| **rwilcox(NN, M, N)**                    |

- Computes either the density (d), probability (p), quantile (q), or
  a random (r) sample of a vector or scalar from a Wilcox distribution.
  
- When simulating a vector or scalar from a Wilcox distribution,
  the value returned is within the natural numbers (e.g. $0, 1, 2, \ldots , 42, \ldots , \mathbb{N}$).

- Under vectorization, e.g. `Rcpp::`, the default distribution parameters are
  as follows:
    - `LOG_P = FALSE`, probabilities, densities are returned as $\log(p)$.
    - `LOWER_TAIL = TRUE`, probabilities are calculated by $P(X \le x)$ instead of $P(X > x)$.

- Examples:


### Wilcoxon Signed Rank Distribution {#signeddist}

|                                         |
|:----------------------------------------|
| **dsignrank( X, N, LOG_P)**             |
| **psignrank( Q, N, LOWER_TAIL, LOG_P)** |
| **qsignrank( P, N, LOWER_TAIL, LOG_P)** |
| **rsignrank(NN, N)**                    |


### Continuous Distributions {#contdist}

#### Beta Distribution {#betadist}

|                                                 |
|:------------------------------------------------|
| **dbeta(X, SHAPE1, SHAPE2, LOG_P)**             |
| **pbeta(Q, SHAPE1, SHAPE2, LOWER_TAIL, LOG_P)** |
| **qbeta(P, SHAPE1, SHAPE2, LOWER_TAIL, LOG_P)** |
| **rbeta(N, SHAPE1, SHAPE2)**                    |

- Computes either the density (d), probability (p), quantile (q), or
  a random (r) sample of a vector or scalar from a Beta distribution.
  
- When simulating a vector or scalar from a Beta distribution,
  the value returned is within [0, 1].

- Under vectorization, e.g. `Rcpp::`, the default distribution parameters are
  as follows:
    - `LOG_P = FALSE`, probabilities, densities are returned as $\log(p)$.
    - `LOWER_TAIL = TRUE`, probabilities are calculated by $P(X \le x)$ instead of $P(X > x)$.

- Examples:

```{Rcpp rcpp_beta_dist}
// Consider X ~ Beta(1,1)
NumericVector xx = NumericVector::create(0.0, 0.25, 0.5, 0.75, 1.0);

// Vector returns
NumericVector densities = Rcpp::dbeta(xx, 1.0, 1.0, false);
NumericVector probs     = Rcpp::pbeta(xx, 1.0, 1.0, true, false);
NumericVector qvals     = Rcpp::qbeta(probs, 1.0, 1.0, true, false);
NumericVector rsamples  = Rcpp::rbeta(5, 1.0, 1.0);

// Scalar Returns
double dval  = R::dbeta(0.5, 1.0, 1.0, false);
double pval  = R::pbeta(0.5, 1.0, 1.0, true, false);
double qval  = R::qbeta(0.85, 1.0, 1.0, true, false);
double rdraw = R::rbeta(1.0, 1.0);
```


#### Cauchy Distribution {#cauchydist}

|                                                    |
|:---------------------------------------------------|
| **dcauchy(X, LOCATION, SCALE, LOG_P)**             |
| **pcauchy(Q, LOCATION, SCALE, LOWER_TAIL, LOG_P)** |
| **qcauchy(P, LOCATION, SCALE, LOWER_TAIL, LOG_P)** |
| **rcauchy(N, LOCATION, SCALE)**                    |

- Computes either the density (d), probability (p), quantile (q), or
  a random (r) sample of a vector or scalar from a Cauchy distribution.
  
- When simulating a vector or scalar from a Cauchy distribution,
  the value returned is within (-infty, infty).

- Under vectorization, e.g. `Rcpp::`, the default distribution parameters are
  as follows:
    - `LOG_P = FALSE`, probabilities, densities are returned as $\log(p)$.
    - `LOWER_TAIL = TRUE`, probabilities are calculated by $P(X \le x)$ instead of $P(X > x)$.

- Examples:

```{Rcpp rcpp_cauchy_dist}
// Consider X ~ Cauchy(loc = 0, SCALE = 1)
NumericVector xx = NumericVector::create(0.0, 0.25, 0.5, 0.75, 1.0);

// Vector returns
NumericVector densities = Rcpp::dcauchy(xx, 0.0, 1.0, false)
NumericVector probs     = Rcpp::pcauchy(xx, 0.0, 1.0, true, false);
NumericVector qvals     = Rcpp::qcauchy(probs, 0.0, 1.0, true, false);
NumericVector rsamples  = Rcpp::rcauchy(20, 0.0, 1.0); 

// Scalar Returns
double dval  = R::dcauchy(0.25, 0.0, 1.0, false);
double pval  = R::pcauchy(0.25, 0.0, 1.0, true, false);
double qval  = R::qcauchy(0.578, 0.0, 1.0, true, false);
double rdraw = R::rcauchy(0.0, 1.0);
```


#### Chi-square Distribution {#chisquaredist}

|                                      |
|:-------------------------------------|
| **dchisq(X, DF, LOG)**               |
| **pchisq(Q, DF, LOWER_TAIL, LOG_P)** |
| **qchisq(P, DF, LOWER_TAIL, LOG_P)** |
| **rchisq(N, DF)**                    |

- Computes either the density (d), probability (p), quantile (q), or
  a random (r) sample of a vector or scalar from a Chi-squared distribution.
  
- When simulating a vector or scalar from a Chi-squared distribution,
  the value returned is within [0, infty).

- Under vectorization, e.g. `Rcpp::`, the default distribution parameters are
  as follows:
    - `LOG_P = FALSE`, probabilities, densities are returned as log(p).
    - `LOWER_TAIL = TRUE`, probabilities are calculated by P(X <= x) instead of P(X > x).

- Examples:

```{Rcpp rcpp_chisq_dist}
// Consider X ~ X^2(df = 2)
NumericVector xx = NumericVector::create(0.0, 0.25, 0.5, 0.75, 1.0);

// Vector returns
NumericVector densities = Rcpp::dchisq(xx, 2, false)
NumericVector probs     = Rcpp::pchisq(xx, 2, true, false);
NumericVector qvals     = Rcpp::qchisq(probs, 2, true, false);
NumericVector rsamples  = Rcpp::rchisq(20, 2); 

// Scalar Returns
double dval  = R::dchisq(0.25, 2, false);
double pval  = R::pchisq(0.5, 2, true, false);
double qval  = R::qchisq(0.22, 2, true, false);
double rdraw = R::rchisq(2);
```

#### Non-central Chi-square Distribution {#nchisquaredist}

|                                            |
|:-------------------------------------------|
| **dnchisq(X, DF, NCP, LOG_P)**             |
| **pnchisq(Q, DF, NCP, LOWER_TAIL, LOG_P)** |
| **qnchisq(P, DF, NCP, LOWER_TAIL, LOG_P)** |

- Computes either the density (d), probability (p), quantile (q), or
  a random (r) sample of a vector or scalar from a Non-central Chi-squared
  distribution.
  
- When simulating a vector or scalar from a Non-central Chi-squared distribution,
  the value returned is within $\left[0, \infty\right)$.

- Under vectorization, e.g. `Rcpp::`, the default distribution parameters are
  as follows:
    - `LOG_P = FALSE`, probabilities, densities are returned as $\log(p)$.
    - `LOWER_TAIL = TRUE`, probabilities are calculated by $P(X \le x)$ instead of $P(X > x)$.

- Examples:

```{Rcpp rcpp_nchisq_dist}
// Consider X ~ X^2(df = 2, ncp = 2.5)
NumericVector xx = NumericVector::create(0.0, 0.25, 0.5, 0.75, 1.0);

// Vector returns
NumericVector densities = Rcpp::dchisq(xx, 2, 2.5, false)
NumericVector probs     = Rcpp::pchisq(xx, 2, 2.5, true, false);
NumericVector qvals     = Rcpp::qchisq(probs, 2, 2.5, true, false);

// Scalar Returns
double dval  = R::dnchisq(0.25, 2, false);
double pval  = R::pnchisq(0.5, 2, true, false);
double qval  = R::qnchisq(0.22, 2, true, false);
```

#### Exponential Distribution {#expdist}

|                                      |
|:-------------------------------------|
| **dexp(X, RATE, LOG_P)**             |
| **pexp(Q, RATE, LOWER_TAIL, LOG_P)** |
| **qexp(P, RATE, LOWER_TAIL, LOG_P)** |
| **rexp(N, RATE)**                    |

- Computes either the density (d), probability (p), quantile (q), or
  a random (r) sample of a vector or scalar from an Exponential distribution under
  the lambda parameterization: f(v) = lambda x exp(-lambda x v)
  
- When simulating a vector or scalar from an Exponential distribution, the value returned
  is within $\left[0, \infty\right)$.

- Under vectorization, e.g. `Rcpp::`, the default distribution parameters are
  as follows:
    - `RATE = 1`, rate refers to the lambda parameter within an exponential
    - `LOG_P = FALSE`, probabilities, densities are returned as $\log(p)$.
    - `LOWER_TAIL = TRUE`, probabilities are calculated by $P(X \le x)$ instead of $P(X > x)$.

- Examples:

```{Rcpp rcpp_exp_dist}
// Consider X ~ Exp(Rate = 1)
NumericVector xx = NumericVector::create(0.0, 0.25, 0.5, 0.75, 1.0);

// Vector returns
NumericVector densities = Rcpp::dexp(xx, 1.0, false)
NumericVector probs     = Rcpp::pexp(xx, 1.0, true, false);
NumericVector qvals     = Rcpp::qexp(probs, 1.0, true, false);
NumericVector rsamples  = Rcpp::rexp(20, 1.0); 

// Scalar Returns
double dval  = R::dexp(0.25, 2, false);
double pval  = R::pexp(0.5, 2, true, false);
double qval  = R::qexp(0.22, 2, true, false);
double rdraw = R::rexp(2);
```


#### F Distribution {#fdist}

|                                        |
|:---------------------------------------|
| **df(X, DF1, DF2, LOG_P)**             |
| **pf(Q, DF1, DF2, LOWER_TAIL, LOG_P)** |
| **qf(P, DF1, DF2, LOWER_TAIL, LOG_P)** |
| **rf(N, DF1, DF2)**                    |


- Computes either the density (d), probability (p), quantile (q), or
  a random (r) sample of a vector or scalar from an F distribution.
  
- When simulating a vector or scalar from an F distribution, the value returned
  is within [0, infty).

- Under vectorization, e.g. `Rcpp::`, the default distribution parameters are
  as follows:
    - `LOG_P = FALSE`, probabilities, densities are returned as $\log(p)$.
    - `LOWER_TAIL = TRUE`, probabilities are calculated by $P(X \le x)$ instead of $P(X > x)$.

- Examples:

```{Rcpp rcpp_f_dist}
// Consider X ~ F(1, 5)
NumericVector xx = NumericVector::create(0.0, 0.25, 0.5, 0.75, 1.0);

// Vector returns
NumericVector densities = Rcpp::df(xx, 1.0, 5.0, false);
NumericVector probs     = Rcpp::pf(xx, 1.0, 5.0 true, false);
NumericVector qvals     = Rcpp::qf(probs, 1.0, 5.0, true, false);
NumericVector rsamples  = Rcpp::rf(20, 1.0, 5.0); 

// Scalar Returns
double dval  = R::df(0.25, 1.0, 5.0, false);
double pval  = R::pf(0.5, 1.0, 5.0, true, false);
double qval  = R::qf(0.49, 1.0, 5.0, true, false);
double rdraw = R::rf(1.0, 5.0);
```


#### Gamma Distribution {#gammadist}

|                                               |
|:----------------------------------------------|
| **dgamma(X, SHAPE, RATE, LOG_P)**             |
| **pgamma(Q, SHAPE, RATE, LOWER_TAIL, LOG_P)** |
| **qgamma(P, SHAPE, RATE, LOWER_TAIL, LOG_P)** |
| **rgamma(N, SHAPE, RATE)**                    |

- Computes either the density (d), probability (p), quantile (q), or
  a random (r) sample of a vector or scalar from a Gamma distribution.
  
- When simulating a vector or scalar from a Gamma distribution, the value returned
  is within $\left[0, \infty\right)$.

- Under vectorization, e.g. `Rcpp::`, the default distribution parameters are
  as follows:
    - `RATE = 1`,
    - `LOG_P = FALSE`, probabilities, densities are returned as $\log(p)$.
    - `LOWER_TAIL = TRUE`, probabilities are calculated by $P(X \le x)$ instead of $P(X > x)$.

- Examples:
 
```{Rcpp rcpp_gamma_dist}
// Consider X ~ Gamma(1, 1)
NumericVector xx = NumericVector::create(0.0, 0.25, 0.5, 0.75, 1.0);

// Vector returns
NumericVector densities = Rcpp::dgamma(xx, 1.0, 1.0, false);
NumericVector probs     = Rcpp::pgamma(xx, 1.0, 1.0, true, false);
NumericVector qvals     = Rcpp::qgamma(probs, 1.0, 1.0, true, false);
NumericVector rsamples  = Rcpp::rgamma(20, 1.0, 1.0); 

// Scalar Returns
double dval  = R::dgamma(0.25, 1.0, 1.0, false);
double pval  = R::pgamma(0.5, 1.0, 1.0, true, false);
double qval  = R::qgamma(0.393, 1.0, 1.0, true, false);
double rdraw = R::rgamma(1.0, 1.0);
```

### Normal Distribution {#normaldist}

|                                           |
|:------------------------------------------|
| **dnorm(X, MEAN, SD, LOG_P)**             |
| **pnorm(Q, MEAN, SD, LOWER_TAIL, LOG_P)** |
| **qnorm(P, MEAN, SD, LOWER_TAIL, LOG_P)** |
| **rnorm(N, MEAN, SD)**                    |

- Computes either the density (d), probability (p), quantile (q), or
  a random (r) sample of a vector or scalar from a Normal distribution.
  
- When simulating a vector or scalar from a Normal distribution, the value returned
  is within $\left(-\infty, \infty\right)$.

- Under vectorization, e.g. `Rcpp::`, the default distribution parameters are
  as follows:
    - `MEAN = 0`, the mean of the distribution
    - `SD = 1`, the standard derivation of the distribution
    - `LOG_P = FALSE`, probabilities, densities are returned as $\log(p)$.
    - `LOWER_TAIL = TRUE`, probabilities are calculated by $P(X \le x)$ instead of $P(X > x)$.

- Examples:
 
```{Rcpp rcpp_normal_dist}
// Consider X ~ Norm(0, 1)
NumericVector xx = NumericVector::create(0.0, 0.25, 0.5, 0.75, 1.0);

// Vector returns
NumericVector densities = Rcpp::dnorm(xx, 0.0, 1.0, false);
NumericVector probs     = Rcpp::pnorm(xx, 0.0, 1.0, true, false);
NumericVector qvals     = Rcpp::qnorm(probs, 0.0, 1.0, true, false);
NumericVector rsamples  = Rcpp::rnorm(20, 0.0, 1.0); 

// Scalar Returns
double dval  = R::dnorm(0.25, 0.0, 1.0, false);
double pval  = R::pnorm(0.95, 0.0, 1.0, true, false);
double qval  = R::qnorm(1.96, 0.0, 1.0, true, false);
double rdraw = R::rnorm(0.0, 1.0);
```


### Log Normal Distribution {#lognormaldist}

|                                                  |
|:-------------------------------------------------|
| **dlnorm(X, MEANLOG, SDLOG, LOG_P)**             |
| **plnorm(Q, MEANLOG, SDLOG, LOWER_TAIL, LOG_P)** |
| **qlnorm(P, MEANLOG, SDLOG, LOWER_TAIL, LOG_P)** |
| **rlnorm(N, MEANLOG, SDLOG)**                    |

- Computes either the density (d), probability (p), quantile (q), or
  a random (r) sample of a vector or scalar from a Log Normal distribution.
  
- When simulating a vector or scalar from a Log Normal distribution, the value returned
  is within $\left[0,\infty\right)$.

- Under vectorization, e.g. `Rcpp::`, the default distribution parameters are
  as follows:
    - `MEANLOG = 0`, the log mean of the distribution
    - `SDLOG = 1`, the log standard derivation of the distribution
    - `LOG_P = FALSE`, probabilities, densities are returned as $\log(p)$.
    - `LOWER_TAIL = TRUE`, probabilities are calculated by $P(X \le x)$ instead of $P(X > x)$.

- Examples:
 
```{Rcpp rcpp_lnorm_dist}
// Consider X ~ LogNorm(0, 1)
NumericVector xx = NumericVector::create(0.0, 0.25, 0.5, 0.75, 1.0);

// Vector returns
NumericVector densities = Rcpp::dlnorm(xx, 0.0, 1.0, false);
NumericVector probs     = Rcpp::plnorm(xx, 0.0, 1.0, true, false);
NumericVector qvals     = Rcpp::qlnorm(probs, 0.0, 1.0, true, false);
NumericVector rsamples  = Rcpp::rlnorm(20, 0.0, 1.0); 

// Scalar Returns
double dval  = R::dlnorm(0.25, 0.0, 1.0, false);
double pval  = R::plnorm(0.5, 0.0, 1.0, true, false);
double qval  = R::qlnorm(0.0452, 0.0, 1.0, true, false);
double rdraw = R::rlnorm(0.0, 1.0);
```

### Logistic Distribution {#logisticdist}

|                                                   |
|:--------------------------------------------------|
| **dlogis(X, LOCATION, SCALE, LOG_P)**             |
| **plogis(Q, LOCATION, SCALE, LOWER_TAIL, LOG_P)** |
| **qlogis(P, LOCATION, SCALE, LOWER_TAIL, LOG_P)** |
| **rlogis(N, LOCATION, SCALE)**                    |

- Computes either the density (d), probability (p), quantile (q), or
  a random (r) sample of a vector or scalar from a Logistic distribution.
  
- When simulating a vector or scalar from a Logistic distribution, the value returned
  is within $\left(-\infty,\infty\right)$.

- Under vectorization, e.g. `Rcpp::`, the default distribution parameters are
  as follows:
    - `LOCATION = 0`, the shift component of the distribution
    - `SCALE = 1`, the dispersion parameter of the distribution that changes the spread e.g. if the SCALE is small, then the distribution is concentrated.
    - `LOG_P = FALSE`, probabilities, densities are returned as $\log(p)$.
    - `LOWER_TAIL = TRUE`, probabilities are calculated by $P(X \le x)$ instead of $P(X > x)$.

- Examples:
 
```{Rcpp rcpp_logis_dist}
// Consider X ~ Logis(0, 1)
NumericVector xx = NumericVector::create(0.0, 0.25, 0.5, 0.75, 1.0);

// Vector returns
NumericVector densities = Rcpp::dlogis(xx, 0.0, 1.0, false);
NumericVector probs     = Rcpp::plogis(xx, 0.0, 1.0, true, false);
NumericVector qvals     = Rcpp::qlogis(probs, 0.0, 1.0, true, false);
NumericVector rsamples  = Rcpp::rlogis(20, 0.0, 1.0); 

// Scalar Returns
double dval  = R::dlogis(0.25, 0.0, 1.0, false);
double pval  = R::plogis(0.5, 0.0, 1.0, true, false);
double qval  = R::qlogis(0.0452, 0.0, 1.0, true, false);
double rdraw = R::rlogis(0.0, 1.0);
```


### Student's T Distribution {#tdist}

**rt()**

### Uniform Distribution {#unifdist}

**runif()**

### Weibull Distribution {#weibulldist}

**rweibull()**


